#!/usr/bin/env bash

# TODO: improve state (broadcast, playback, remote control of either)

##
# utility functions
##

function integer_tween() {
	local command from to value i
	command=$1
	from=$2
	to=$3
	for i in {1..10}; do
		value=$((($to-$from)*$i/10+$from))
		eval "${command/\%\%/$value}"
		gsleep 0.1
	done
	eval "${command/\%\%/$to}"
}

function set_volume() {
	echo "volume $1 1" >> "$control_file"
	echo $1 > $volume_file
}

function get_volume() {
	cat $volume_file
}

function effect_fade() {
	volume_before_fade=$(get_volume)
	integer_tween "set_volume %%" volume_before_fade $1
}

function effect_fadeout() {
	effect_fade 0
}

function effect_fadein() {
	local target_volume

	[[ -n $volume_before_fade ]] && target_volume=$volume_before_fade || target_volume=$default_volume
	effect_fade $target_volume
}

function toggle_sticky() {
	sticky_file="$service_dir/.sticky"
	[[ -f $sticky_file ]] && rm $sticky_file || touch $sticky_file
}

function kill_daemons() {
	echo "killing daemons"
	if [[ $broadcast != true && $sticky != true ]]; then # other session, PIDs unknown
		sudo killall jackd icecast darkice
	else
		if [[ -n ${jackd_status[0]} ]]; then
			kill -HUP ${jackd_status[0]}
		fi

		if [[ -n ${icecast_status[0]} ]]; then
			kill -HUP ${icecast_status[0]}
		fi

		if [[ -n ${darkice_status[0]} ]]; then
			kill -HUP ${darkice_status[0]}
		fi
	fi

	[[ -a "$control_file" ]] && rm -rf "$control_file"
	[[ -f "$volume_file" ]] && rm -rf "$volume_file"
}

function clean_exit() {
	local status message

	[[ -z $1 ]] && status=0 || status=$1

	if [[ $broadcast = true ]]; then

		if [[ $status = 0 && $sticky = true ]]; then
			echo "sticky: keeping radio station running"
		else
			kill_daemons
		fi

	fi

	[[ -n $2 ]] && message=": $message"
	echo "exiting pirr$message"

	exit $status
}

##
# setup
##

wd="$(pwd)"
[[ -L "$0" ]] && script_path="$(readlink $0)" || script_path="$0"
cd "$(dirname $script_path)"
script_dir="$(pwd)"
service_dir="$script_dir/.pirr"
control_file="$service_dir/.mplayercontrol"
volume_file="$service_dir/.mplayervolume"
default_volume=25
duck_volume=5
[[ ! -f $volume_file ]] && set_volume $default_volume
cd "$wd"

video_options=-novideo
broadcast=false

eq_boom=2:8:0:0:0:0:0:0:0:0

##
# operation
##

while getopts "sve:by:V:l:af:c:npqSk:" flag
do

	[[ -z $first_optind ]] && first_optind=$OPTIND

  case $flag in
    s ) shuffle=true;;
    v ) video_options=;;
		e ) [[ $OPTARG =~ : ]] && eq="$OPTARG" || eq="$(eval "echo \$eq_$OPTARG")"; [[ -n $eq ]] && audio_filters="$audio_filters equalizer=$eq";;
		b ) broadcast=true;;
		y ) message="$OPTARG";;
    V ) voice="$OPTARG";;
		l ) list="$OPTARG";;
		a ) list_append=true;;
		n ) skip=1;  echo "Skipping foward";;
		p ) skip=-1; echo "Skipping backward";;
		q ) kill=true;;

		f ) effect="$OPTARG";effect_optind=$OPTIND;;
		c ) command="$OPTARG";;

		S ) sticky=true;;
		k ) seek=$OPTARG;;
  esac

done

shift $((OPTIND-1)); OPTIND=1

mplayer_options="$@"

if [[ -n $message || $broadcast = true ]]; then
	if [[ Darwin = $(uname) ]]; then
		audio_driver=coreaudio
		device_id=$(say -a ? | grep 'Soundflower (2ch)' | perl -pe 's/^\s+(\d+).*$/$1/')
	else
		audio_driver="help"
		broadcast=false
		message=
		echo "-b (broadcast) and -y (say) are currently only supported on Mac"
		sleep 1
	fi
fi

if [[ -n $list ]]; then

	if [[ ! $list =~ "^https?://" ]]; then # playlist on local filesystem

		if [[ ! $list =~ "^/" ]]; then # relative path
			list=${list/.m3u/}
			listpath=$script_dir/playlists/$list.m3u
		fi

		if [[ ! -f $listpath ]]; then
			echo "Playlist '$listpath' doesn't exist. Exiting."
			exit 1
		fi

	fi

	playlist_option="-playlist $listpath"

fi

if [[ -a "$control_file" ]]; then # broadcast is already running

	playlist_option= # unset playlist option: do not start up a new player

	if [[ -n $effect && $effect_optind -eq $first_optind ]]; then effect_$effect; fi

	##
	# playback operations
	##

	if [[ $kill = true ]]; then

		echo 'quit' >> "$control_file"

		kill_daemons

	elif [[ -n $listpath ]]; then

		if [[ $shuffle = true ]]; then

			new_listpath="$service_dir/tmp_playlist.m3u"

			cat "$listpath" | gshuf > "$new_listpath"

			listpath="$new_listpath"

		fi

		[[ $list_append = true ]] && append=1

		echo "loadlist '$listpath' $append"  >> "$control_file"

	elif [[ -n $skip ]]; then

		echo "pt_step $skip 1" >> "$control_file"

	elif [[ -n $command ]]; then

		echo -e "$command" >> "$control_file"

	fi

	##
	# other audio input
	##

	if [[ -n $message ]]; then

		[[ -n $voice ]] && voice_options="-v $voice"

		if [[ ? = $voice ]]; then
			say $voice_options
		else

			current_volume=$(get_volume)
			echo "Ducking audio and speaking message \"$message\"."
			effect_fade $duck_volume
			say -a $device_id $voice_options "$message"
			effect_fade $current_volume

		fi

	fi

	if [[ -n $effect && $effect_optind -gt $first_optind ]]; then effect_$effect; fi

elif [[ $broadcast = true ]]; then # new brodcast

	audio_options="$audio_options -ao $audio_driver"

	if [[ -n $device_id ]]; then
		audio_options="$audio_options:device_id=$device_id"
	fi

	echo "starting jackd"
	jackd -d coreaudio &> /dev/null &
	jackd_status=($!,$?)
	sleep 1

	echo "starting icecast"
	icecast -c "$service_dir/icecast.xml" &> /dev/null &
	icecast_status=($! $?)
	sleep 1

	echo "starting darkice"
	darkice -v 10 -c "$service_dir/darkice.cfg" &> /dev/null &
	darkice_status=($! $?)

	if [[ 0 != ${darkice_status[1]} ]]; then
		echo "Make sure soundflower is running, and is set to be default input and output. Once the radio is being broadcast, you can set your system default input and output back to the built-in."
		clean_exit 1
	fi

	sleep 1

fi

if [[ $shuffle = true ]]; then
	shuffle_option="-shuffle"
fi

if [[ -n $audio_filters ]]; then
	audio_options="$audio_options -af $audio_filters"
fi

if [[ -n $playlist_option || -n $mplayer_options ]]; then

	mkfifo "$control_file"

	input_options="-slave -input file=\"$control_file\""

	mplayer $input_options $video_options $audio_options $shuffle_option -loop 0 $playlist_option $mplayer_options

	if [[ $broadcast = true ]]; then
		clean_exit 0
	fi

fi
