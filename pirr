#!/usr/bin/env bash

# TODO: improve state (broadcast, playback, remote control of either)

##
# environment
##

wd="$(pwd)"
[[ -L "$0" ]] && script_path="$(readlink $0)" || script_path="$0"
cd "$(dirname $script_path)"
script_dir="$(pwd)"
cd "$wd"
service_dir="$script_dir/.pirr"
control_file="$service_dir/.mplayercontrol"
volume_file="$service_dir/.mplayervolume"

##
# utility functions
##

. $service_dir/functions

##
# setup
##

default_volume=25
duck_volume=5
[[ ! -f $volume_file ]] && set_volume $default_volume

video_options=-novideo
broadcast=false

eq_boom=2:8:0:0:0:0:0:0:0:0

##
# operation
##

while getopts "sve:by:V:l:anpkqf:c:St:" flag
do

	[[ -z $first_optind ]] && first_optind=$OPTIND

  case $flag in
    s ) shuffle=true;;
    v ) verbose=true;;
		e ) [[ $OPTARG =~ : ]] && eq="$OPTARG" || eq="$(eval "echo \$eq_$OPTARG")"; [[ -n $eq ]] && audio_filters="$audio_filters equalizer=$eq";;
		b ) broadcast=true;;
		y ) message="$OPTARG";;
    V ) voice="$OPTARG";;
		l ) list="$OPTARG";;
		a ) list_append=true;;
		n ) skip=1;  shout "Skipping foward";;
		p ) skip=-1; shout "Skipping backward";;
		k ) kill=true;;
		q ) quiet=true;;

		f ) effect="$OPTARG";effect_optind=$OPTIND;;
		c ) command="$OPTARG";;

		S ) sticky=true;;
		t ) seek=$OPTARG;;
  esac

done

whisper "verbose output enabled"

shift $((OPTIND-1)); OPTIND=1

mplayer_options="$@"

if [[ -n $message || $broadcast = true ]]; then
	if [[ Darwin = $(uname) ]]; then
		audio_driver=coreaudio
		device_id=$(say -a ? | grep 'Soundflower (2ch)' | perl -pe 's/^\s+(\d+).*$/$1/')
		whisper "audio_driver: $audio_driver, device_id: $device_id"
	else
		audio_driver="help"
		broadcast=false
		message=
		shout "-b (broadcast) and -y (say) are currently only supported on Mac"
		sleep 1
	fi
fi

if [[ -n $list ]]; then

	if [[ ! $list =~ "^https?://" ]]; then # playlist on local filesystem

		if [[ ! $list =~ "^/" ]]; then # relative path
			list=${list/.m3u/}
			listpath=$script_dir/playlists/$list.m3u
			whisper "resolved $list to $listpath"
		fi

		if [[ ! -f $listpath ]]; then
			shout "Playlist '$listpath' doesn't exist. Exiting."
			clean_exit 1
		fi

	fi

	playlist_option="-playlist $listpath"

fi

if [[ -a "$control_file" ]]; then

	whisper "broadcast is already running"

	playlist_option= # unset playlist option: do not start up a new player

	if [[ -n $effect && $effect_optind -eq $first_optind ]]; then effect_$effect; fi

	##
	# playback operations
	##

	if [[ $kill = true ]]; then

		whisper "sending to mplayer: quit"

		echo 'quit' >> "$control_file"

		kill_daemons # FIXME: check if they need to be killed first

	elif [[ -n $listpath ]]; then

		if [[ $shuffle = true ]]; then

			new_listpath="$service_dir/tmp_playlist.m3u"

			whisper "shuffling list into $new_listpath"

			cat "$listpath" | gshuf > "$new_listpath"

			listpath="$new_listpath"

		fi

		[[ $list_append = true ]] && append=1

		echo "loadlist '$listpath' $append"  >> "$control_file"

	elif [[ -n $skip ]]; then

		whisper "skipping: $skip"

		echo "pt_step $skip 1" >> "$control_file"

	elif [[ -n $command ]]; then

		whisper "sending to mplayer: $command"

		echo -e "$command" >> "$control_file"

	fi

	##
	# other audio input
	##

	if [[ -n $message ]]; then

		[[ -n $voice ]] && voice_options="-v $voice"

		if [[ ? = $voice ]]; then
			whisper "listing voices"
			say $voice_options
		else
			current_volume=$(get_volume)
			shout "Ducking audio and speaking message \"$message\"."
			effect_fade $duck_volume
			say -a $device_id $voice_options "$message"
			effect_fade $current_volume
		fi

	fi

	if [[ -n $effect && $effect_optind -gt $first_optind ]]; then effect_$effect; fi

elif [[ $broadcast = true ]]; then # new brodcast

	audio_options="$audio_options -ao $audio_driver"

	if [[ -n $device_id ]]; then
		audio_options="$audio_options:device_id=$device_id"
	fi

	start_daemon jackd -d coreaudio
	sleep 1
	start_daemon icecast -c "$service_dir/icecast.xml"
	sleep 1
	start_daemon darkice -v 10 -c "$service_dir/darkice.cfg"

	if [[ 0 != $(get_daemon_result darkice) ]]; then
		shout "Make sure soundflower is running, and is set to be default input and output. Once the radio is being broadcast, you can set your system default input and output back to the built-in."
		clean_exit 1
	fi

	sleep 1

fi

if [[ $shuffle = true ]]; then
	shuffle_option="-shuffle"
fi

if [[ -n $audio_filters ]]; then
	audio_options="$audio_options -af $audio_filters"
fi

if [[ -n $playlist_option || -n $mplayer_options ]]; then

	mkfifo "$control_file"

	input_options="-slave -input file=\"$control_file\""

	mplayer $input_options $video_options $audio_options $shuffle_option -loop 0 $playlist_option $mplayer_options

	if [[ $broadcast = true ]]; then
		clean_exit 0
	fi

fi
