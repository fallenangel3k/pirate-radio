#!/usr/bin/env bash

function shout() {
	[[ $quiet != true ]] && echo $@ >> /dev/stderr
}
function whisper() {
	[[ $verbose = true ]] && echo $@ >> /dev/stderr
}

function integer_tween() {
	local command from to value i
	command=$1
	from=$2
	to=$3
	for i in {1..10}; do
		value=$((($to-$from)*$i/10+$from))
		eval "${command/\%\%/$value}"
		gsleep 0.1
	done
	eval "${command/\%\%/$to}"
}

function set_volume() {
	[[ -a "$control_file" ]] && echo "volume $1 1" >> "$control_file"
	echo $1 > $volume_file
}

function get_volume() {
	cat $volume_file
}

function effect_fade() {
	whisper "effect_fade $@"
	volume_before_fade=$(get_volume)
	integer_tween "set_volume %%" volume_before_fade $1
}

function effect_fadeout() {
	whisper "effect_fadeout $@"
	effect_fade 0
}

function effect_fadein() {
	whisper "effect_fadein $@"
	local target_volume

	[[ -n $volume_before_fade ]] && target_volume=$volume_before_fade || target_volume=$default_volume
	effect_fade $target_volume
}

function toggle_sticky() {
	sticky_file="$tmp_dir/.sticky"
	[[ -f $sticky_file ]] && rm $sticky_file || touch $sticky_file
}

start_daemon() {
	local name options status pid_file output

	if [[ $1 = '-o' ]]; then
		output_file="$2"
		shift 2
	fi

	name=$1
	shift 1
	options=("$@")
	whisper "starting daemon: $name, ${#options} options"

	pid_file="$tmp_dir/pid_$name"
	# output="$tmp_dir/fifo_$name"
	# mkfifo "$output"
	output="/dev/null"

	$name ${options[@]} &> /dev/null &

	eval "status_$name=($! $?)"
	eval "echo \${status_$name[0]} > \"$pid_file\""
}

get_daemon_status() {
	local name
	name=$1
	status=$(eval "echo \${status_$name[1]}")
	echo $status
}

kill_daemon() {
	local name pid_file pid
	name=$1
	pid_file="$tmp_dir/pid_$name"
	if [[ -f $pid_file ]]; then
		pid=$(cat "$pid_file")
		whisper "killing daemon $name, (PID $pid)"
		kill -HUP $pid
		rm "$pid_file"
	else
		whisper "no known process $name"
	fi
}

function kill_daemons() {
	local process_notes basename name

	process_notes=$(ls -1 "$tmp_dir/pid_"*)
	if [[ -z $process_notes ]]; then
		whisper "no daemons to kill"
	else
		whisper "killing daemons"
		for note in $process_notes; do
			basename="$(basename "$note")"
			name="${basename/pid_/}"
			kill_daemon $name
		done
	fi

	[[ -a "$control_file" ]] && rm -rf "$control_file"
	[[ -f "$volume_file" ]] && rm -rf "$volume_file"
}

function clean_exit() {
	local status message

	[[ -z $1 ]] && status=0 || status=$1

	if [[ $broadcast = true ]]; then

		if [[ $status = 0 && $sticky = true ]]; then
			echo "sticky: keeping radio station running"
		else
			kill_daemons
		fi

	fi

	[[ -n $2 ]] && message=": $message"
	echo "exiting pirr$message"

	exit $status
}

function get_queue_length() {
	local name length
	name=$1
	length=$(eval "echo \${#queue_$name[@]}")
	echo $length
}

function advance_queue() {
	local name message
	name=$1
	shift 1
	message="$@"

	action="$(pop_queue $name)"

	function_with_args="${name}_${action}"
	function=${function_with_args/ */}
	if [[ $(type -t $function) = function ]]; then
		if [[ -n $message ]]; then
			whisper "${message/\{\}/$value}"
		fi
		$function_with_args
	else
		whisper "no function: $function_with_args"
	fi
}

function enqueue_method() {
	local name action
	name=$1
	shift 1
	action="$@"
	if [[ $(get_queue_length $name) -le 0 ]]; then # queue doesn't exist
		eval "queue_${name}=()"
	fi
	eval "queue_${name}+=(\"$action\")"
	whisper "enqueue $name '$@' ($(get_queue_length $name) in queue)"
}

function pop_queue() {
	local name value
	name="$1"

	if [[ $(get_queue_length $name) -gt 0 ]]; then

		# store the first item
		value="$(eval "echo \${queue_$name[0]}")"

		# remove the first item from the list
		eval "queue_${name}=(\"\${queue_${name}[@]:1}\")"

		echo "$value"
	fi
}

function purge_queue() {
	local name message
	name=$1
	shift 1
	messsage="$@"
	while [[ $(get_queue_length $name) -gt 0 ]]; do
		advance_queue $name "$messsage"
	done
}
